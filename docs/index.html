<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interest Rate Swap Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class'
        }
    </script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .table-container {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
        }
        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .dark th, .dark td {
            border-bottom-color: #374151;
        }
        th {
            background-color: #f9fafb;
            font-weight: 600;
            color: #374151;
        }
        .dark th {
            background-color: #1f2937;
            color: #e5e7eb;
        }
        td {
            color: #374151;
        }
        .dark td {
            color: #e5e7eb;
        }
        tr:hover {
            background-color: #f9fafb;
        }
        .dark tr:hover {
            background-color: #1f2937;
        }
        .input-group {
            margin-bottom: 1rem;
        }
        .input-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.25rem;
            transition: color 0.3s ease;
        }
        .dark .input-group label {
            color: #d1d5db;
        }
        .input-group input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            background-color: white;
            color: #1f2937;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        .dark .input-group input {
            background-color: #1f2937;
            border-color: #4b5563;
            color: #f3f4f6;
        }
        .input-group input:focus {
            outline: none;
            border-color: #3b82f6;
            ring: 2px;
            ring-color: #3b82f6;
        }
        .section-header {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #3b82f6;
            transition: color 0.3s ease;
        }
        .dark .section-header {
            color: #f3f4f6;
        }
        .dark-mode-toggle {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 50;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            padding: 0.5rem;
            cursor: pointer;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .dark .dark-mode-toggle {
            background-color: #1f2937;
            border-color: #4b5563;
        }
        .dark-mode-toggle:hover {
            background-color: #f9fafb;
        }
        .dark .dark-mode-toggle:hover {
            background-color: #374151;
        }
        .icon {
            width: 1.5rem;
            height: 1.5rem;
            display: block;
        }
        /* Editable table input styling */
        .editable-input {
            background: transparent;
            border: none;
            width: 100%;
            padding: 0.75rem;
            font-size: inherit;
            color: inherit;
            text-align: right;
            transition: background-color 0.2s ease;
        }
        .editable-input:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }
        .editable-input:focus {
            outline: none;
            background-color: rgba(59, 130, 246, 0.15);
            box-shadow: inset 0 0 0 2px #3b82f6;
        }
        .dark .editable-input:hover {
            background-color: rgba(59, 130, 246, 0.2);
        }
        .dark .editable-input:focus {
            background-color: rgba(59, 130, 246, 0.25);
        }
        /* Remove spinner from number inputs */
        .editable-input::-webkit-outer-spin-button,
        .editable-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .editable-input[type=number] {
            -moz-appearance: textfield;
        }
        /* Subsection header */
        .subsection-header {
            font-size: 0.875rem;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .dark .subsection-header {
            color: #9ca3af;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300">
    <!-- Dark Mode Toggle -->
    <button id="darkModeToggle" class="dark-mode-toggle" aria-label="Toggle dark mode" title="Toggle dark mode">
        <svg id="sunIcon" class="icon text-gray-700 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
        </svg>
        <svg id="moonIcon" class="icon text-gray-700 dark:text-gray-300 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
        </svg>
    </button>

    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <h1 class="text-4xl font-bold text-gray-900 dark:text-gray-100 mb-8 transition-colors">Interest Rate Swap Analysis</h1>

        <!-- Two Column Results Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Market Analysis (Left Column) -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors">
                <h2 class="section-header">Market Analysis</h2>

                <h3 class="subsection-header">Market Rates <span class="text-blue-500 dark:text-blue-400">(editable)</span></h3>
                <div class="table-container mb-6" id="market_rates_table"></div>

                <!-- Total Arbitrage Highlight Box -->
                <div class="p-4 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900/30 dark:to-indigo-900/30 rounded-lg border border-blue-200 dark:border-blue-700">
                    <div class="flex items-center justify-between">
                        <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Total Arbitrage Available:</span>
                        <span id="total_arbitrage" class="text-xl font-bold text-blue-600 dark:text-blue-400">0.00%</span>
                    </div>
                </div>
            </div>

            <!-- Swap Analysis (Right Column) -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors">
                <h2 class="section-header">Swap Analysis</h2>

                <h3 class="subsection-header">Swap Terms <span class="text-blue-500 dark:text-blue-400">(editable)</span></h3>
                <div class="table-container mb-6" id="swap_details_table"></div>

                <h3 class="subsection-header">Party Positions</h3>
                <div class="table-container" id="party_positions_table"></div>
            </div>
        </div>
    </div>

    <script>
        // Dark Mode Management
        function initDarkMode() {
            const htmlElement = document.documentElement;
            const darkModeToggle = document.getElementById('darkModeToggle');
            const sunIcon = document.getElementById('sunIcon');
            const moonIcon = document.getElementById('moonIcon');

            // Check for saved preference or default to system preference
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (savedTheme === 'dark' || (!savedTheme && systemPrefersDark)) {
                htmlElement.classList.add('dark');
                htmlElement.classList.remove('light');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                htmlElement.classList.remove('dark');
                htmlElement.classList.add('light');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }

            // Toggle function
            darkModeToggle.addEventListener('click', () => {
                const isDark = htmlElement.classList.contains('dark');

                if (isDark) {
                    htmlElement.classList.remove('dark');
                    htmlElement.classList.add('light');
                    localStorage.setItem('theme', 'light');
                    sunIcon.classList.remove('hidden');
                    moonIcon.classList.add('hidden');
                } else {
                    htmlElement.classList.add('dark');
                    htmlElement.classList.remove('light');
                    localStorage.setItem('theme', 'dark');
                    sunIcon.classList.add('hidden');
                    moonIcon.classList.remove('hidden');
                }
            });
        }

        // Initialize dark mode before page fully loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initDarkMode);
        } else {
            initDarkMode();
        }

        // Constants
        const NOTIONAL = 1000000.0;
        const START_DATE = new Date();
        const END_DATE = new Date('2030-01-01');

        // InterestRate class
        class InterestRate {
            constructor(rate, rateType) {
                if (typeof rate !== 'number') {
                    throw new Error('Rate must be a number');
                }
                if (rateType !== 'fixed' && rateType !== 'floating') {
                    throw new Error('Rate type must be fixed or floating');
                }
                this.rate = rate;
                this.rateType = rateType;
            }

            get isFloating() {
                return this.rateType === 'floating';
            }

            add(other) {
                if (typeof other === 'number') {
                    return new InterestRate(this.rate + other, this.rateType);
                } else if (other instanceof InterestRate) {
                    const newType = this.isFloating || other.isFloating ? 'floating' : 'fixed';
                    return new InterestRate(this.rate + other.rate, newType);
                }
                throw new Error('Unsupported operand type for add');
            }

            subtract(other) {
                if (typeof other === 'number') {
                    return new InterestRate(this.rate - other, this.rateType);
                } else if (other instanceof InterestRate) {
                    const newType = this.isFloating || other.isFloating ? 'floating' : 'fixed';
                    return new InterestRate(this.rate - other.rate, newType);
                }
                throw new Error('Unsupported operand type for subtract');
            }

            toString() {
                if (this.rateType === 'fixed') {
                    return (this.rate * 100).toFixed(2) + '%';
                } else {
                    const bps = Math.abs(Math.round(this.rate * 10000));
                    const sign = this.rate >= 0 ? '+' : '-';
                    return `S${sign}${bps}`;
                }
            }
        }

        // Party class
        class Party {
            constructor(name, fixedRate, floatingRateDelta, preference) {
                this.name = name;
                this._fixedRate = new InterestRate(fixedRate, 'fixed');
                this._floatingRateDelta = new InterestRate(floatingRateDelta, 'floating');
                if (preference !== 'fixed' && preference !== 'floating') {
                    throw new Error('Preference must be fixed or floating');
                }
                this.preference = preference;
            }

            get fixedRate() {
                return this._fixedRate;
            }

            get floatingRateDelta() {
                return this._floatingRateDelta;
            }

            getFloatingRate(benchmarkRate) {
                return benchmarkRate + this.floatingRateDelta.rate;
            }

            getRate(type) {
                if (type === 'fixed') {
                    return this.fixedRate;
                } else {
                    return this.floatingRateDelta;
                }
            }

            toString() {
                return this.name;
            }
        }

        // InterestRateSwap class
        class InterestRateSwap {
            constructor(fixedRate, floatingRateDelta, notional, fixedRatePayer, floatingRatePayer, startDate, endDate) {
                if (notional <= 0) {
                    throw new Error('Notional must be positive');
                }
                if (startDate >= endDate) {
                    throw new Error('Start date must be before end date');
                }

                this._fixedRate = new InterestRate(fixedRate, 'fixed');
                this._floatingRateDelta = new InterestRate(floatingRateDelta, 'floating');
                this.notional = notional;
                this.fixedRatePayer = fixedRatePayer;
                this.floatingRatePayer = floatingRatePayer;
                this.startDate = startDate;
                this.endDate = endDate;
            }

            get fixedRate() {
                return this._fixedRate;
            }

            get floatingRateDelta() {
                return this._floatingRateDelta;
            }

            calculateFixedLegPayment() {
                return this.notional * this.fixedRate.rate / 2;
            }

            calculateFloatingLegPayment(benchmarkRate) {
                const floatingRate = benchmarkRate + this.floatingRateDelta.rate;
                return this.notional * floatingRate / 2;
            }

            getPayingPositionForParty(party) {
                return party === this.fixedRatePayer ? 'fixed' : 'floating';
            }

            getReceivingPositionForParty(party) {
                if (party === this.fixedRatePayer) {
                    return 'floating';
                } else if (party === this.floatingRatePayer) {
                    return 'fixed';
                }
                return null;
            }

            getRate(type) {
                if (type === 'fixed') {
                    return this.fixedRate;
                } else {
                    return this.floatingRateDelta;
                }
            }
        }

        // OpportunityAnalyzer class
        class OpportunityAnalyzer {
            constructor(partyA, partyB) {
                this.partyA = partyA;
                this.partyB = partyB;
                this._comparatives = null;
                this._comparativeAdvantages = null;
                this._comparativeDisadvantages = null;
            }

            get comparatives() {
                if (!this._comparatives) {
                    this._comparatives = {};
                    this._comparatives[this.partyA.name] = this.comparativesForParty(this.partyA);
                    this._comparatives[this.partyB.name] = this.comparativesForParty(this.partyB);
                }
                return this._comparatives;
            }

            get comparativeAdvantages() {
                if (!this._comparativeAdvantages) {
                    this._comparativeAdvantages = {};
                    this._comparativeAdvantages[this.partyA.name] = this.determineComparativeAdvantageForParty(this.partyA);
                    this._comparativeAdvantages[this.partyB.name] = this.determineComparativeAdvantageForParty(this.partyB);
                }
                return this._comparativeAdvantages;
            }

            get comparativeDisadvantages() {
                if (!this._comparativeDisadvantages) {
                    this._comparativeDisadvantages = {};
                    this._comparativeDisadvantages[this.partyA.name] = this.determineComparativeDisadvantageForParty(this.partyA);
                    this._comparativeDisadvantages[this.partyB.name] = this.determineComparativeDisadvantageForParty(this.partyB);
                }
                return this._comparativeDisadvantages;
            }

            comparativesForParty(party) {
                const counterparty = party === this.partyA ? this.partyB : this.partyA;
                const fixedDiff = party.fixedRate.subtract(counterparty.fixedRate);
                const floatDiff = party.floatingRateDelta.subtract(counterparty.floatingRateDelta);
                return { fixed: fixedDiff.rate, floating: floatDiff.rate };
            }

            determineComparativeAdvantageForParty(party) {
                const comp = this.comparatives[party.name];
                if (comp.fixed < comp.floating) {
                    return { type: 'fixed', rate: comp.fixed };
                } else if (comp.floating < comp.fixed) {
                    return { type: 'floating', rate: comp.floating };
                } else {
                    return { type: 'none', rate: 0 };
                }
            }

            determineComparativeDisadvantageForParty(party) {
                const comp = this.comparatives[party.name];
                if (comp.fixed > comp.floating) {
                    return { type: 'fixed', rate: comp.fixed };
                } else if (comp.floating > comp.fixed) {
                    return { type: 'floating', rate: comp.floating };
                } else {
                    return { type: 'none', rate: 0 };
                }
            }

            calculateTotalArbitrageAvailable() {
                return -(this.comparativeAdvantages[this.partyA.name].rate +
                         this.comparativeAdvantages[this.partyB.name].rate);
            }

            findFixedRatePayer() {
                if (this.comparativeAdvantages[this.partyA.name].type === 'fixed') {
                    return this.partyB;
                } else if (this.comparativeAdvantages[this.partyB.name].type === 'fixed') {
                    return this.partyA;
                } else {
                    return this.partyA.fixedRate.rate > this.partyB.fixedRate.rate ? this.partyA : this.partyB;
                }
            }
        }

        // InterestRateSwapAnalyzer class
        class InterestRateSwapAnalyzer {
            constructor(partyA, partyB, interestRateSwap) {
                if (!partyA || !partyB || !interestRateSwap) {
                    throw new Error('All parameters must be provided');
                }
                this.partyA = partyA;
                this.partyB = partyB;
                this.interestRateSwap = interestRateSwap;
                this.opportunityAnalyzer = new OpportunityAnalyzer(partyA, partyB);
            }

            analyze() {
                const partyAAnalysis = this.analyzeParty(this.partyA);
                const partyBAnalysis = this.analyzeParty(this.partyB);

                return {
                    totalArbitrage: this.opportunityAnalyzer.calculateTotalArbitrageAvailable(),
                    fixedRate: this.interestRateSwap.fixedRate.rate,
                    floatingRate: this.interestRateSwap.floatingRateDelta.rate,
                    partyAAnalysis: partyAAnalysis,
                    partyBAnalysis: partyBAnalysis
                };
            }

            analyzeParty(party) {
                const payingPosition = this.interestRateSwap.getPayingPositionForParty(party);
                const receivingPosition = this.interestRateSwap.getReceivingPositionForParty(party);
                const benefit = this.getMarketPayingVsSwapReceivingBenefit(party);

                return {
                    party: party,
                    comparativeAdvantage: this.opportunityAnalyzer.comparativeAdvantages[party.name],
                    marketPayingVsSwapReceivingBenefit: benefit,
                    payingPosition: payingPosition,
                    receivingPosition: receivingPosition,
                    marketImprovement: this.calculateMarketImprovement(party),
                    totalCost: this.calculateTotalCost(party)
                };
            }

            calculateMarketImprovement(party) {
                return (
                    party.getRate(this.opportunityAnalyzer.comparativeDisadvantages[party.name].type).rate
                    - (
                        this.interestRateSwap.getRate(
                            this.interestRateSwap.getPayingPositionForParty(party)
                        ).rate
                        + this.getMarketPayingVsSwapReceivingBenefit(party)
                    )
                );
            }

            calculateTotalCost(party) {
                return (
                    this.interestRateSwap.getRate(
                        this.interestRateSwap.getPayingPositionForParty(party)
                    ).rate + this.getMarketPayingVsSwapReceivingBenefit(party)
                );
            }

            getMarketPayingVsSwapReceivingBenefit(party) {
                return -(
                    party.getRate(this.opportunityAnalyzer.comparativeAdvantages[party.name].type).rate
                    - this.interestRateSwap.getRate(
                        this.interestRateSwap.getReceivingPositionForParty(party)
                    ).rate
                );
            }

            toMarketRatesData() {
                return [
                    {
                        'Party': 'Party A',
                        'Fixed Rate (Market)': this.partyA.fixedRate.toString(),
                        'Floating Rate (Market)': this.partyA.floatingRateDelta.toString()
                    },
                    {
                        'Party': 'Party B',
                        'Fixed Rate (Market)': this.partyB.fixedRate.toString(),
                        'Floating Rate (Market)': this.partyB.floatingRateDelta.toString()
                    }
                ];
            }

            toOpportunityAnalysisData(summary) {
                return [{
                    'Total Arbitrage Available': (summary.totalArbitrage * 100).toFixed(2) + '%'
                }];
            }

            toSwapDetailsData(summary) {
                return [{
                    'Swap Fixed Rate': this.interestRateSwap.fixedRate.toString(),
                    'Swap Floating Rate': this.interestRateSwap.floatingRateDelta.toString()
                }];
            }

            toPartyPositionsData(summary) {
                const data = [];
                for (const partyAnalysis of [summary.partyAAnalysis, summary.partyBAnalysis]) {
                    const payingRate = this.interestRateSwap.getRate(partyAnalysis.payingPosition);
                    const receivingRate = this.interestRateSwap.getRate(partyAnalysis.receivingPosition);
                    const marketPositionType = this.opportunityAnalyzer.comparativeAdvantages[partyAnalysis.party.name].type;
                    const marketRate = partyAnalysis.party.getRate(marketPositionType);

                    const oppositeMarketPosition = marketPositionType === 'fixed' ? 'floating' : 'fixed';
                    const oppositeMarketRate = partyAnalysis.party.getRate(oppositeMarketPosition);

                    const netPosition = payingRate.subtract(this.getMarketPayingVsSwapReceivingBenefit(partyAnalysis.party));
                    const netMarketBenefit = oppositeMarketRate.rate - netPosition.rate;

                    data.push({
                        'Party': partyAnalysis.party.name,
                        'Swap Paying Rate': payingRate.toString(),
                        'Swap Receiving Rate': receivingRate.toString(),
                        'Market Position': marketRate.toString(),
                        'Benefit': (this.getMarketPayingVsSwapReceivingBenefit(partyAnalysis.party) * 100).toFixed(2) + '%',
                        'Net Position': netPosition.toString(),
                        'Net Market Benefit': (netMarketBenefit * 100).toFixed(2) + '%'
                    });
                }
                return data;
            }
        }

        // Field mappings for editable cells
        const EDITABLE_FIELDS = {
            'Fixed Rate (Market)': {
                'Party A': 'a_fixed',
                'Party B': 'b_fixed'
            },
            'Floating Rate (Market)': {
                'Party A': 'a_float_delta',
                'Party B': 'b_float_delta'
            },
            'Swap Fixed Rate': 'swap_fixed_rate',
            'Swap Floating Rate': 'swap_floating_rate'
        };

        // Current input values (initialized with defaults, updated by editable inputs)
        let inputValues = {
            a_fixed: 10.45,
            a_float_delta: 0.75,
            b_fixed: 9.65,
            b_float_delta: 0.25,
            swap_fixed_rate: 9.6,
            swap_floating_rate: 0.10
        };

        // Handle editable input change - only updates read-only parts to avoid focus loss
        function handleEditableChange(inputElement) {
            const field = inputElement.dataset.field;
            const value = parseFloat(inputElement.value);

            if (!isNaN(value)) {
                inputValues[field] = value;
                updateCalculations();  // Only update read-only parts, not editable tables
            }
        }

        // Helper function to create HTML table with optional editable cells
        function createTable(data, options = {}) {
            const { transpose = false, editable = false } = options;

            if (!data || data.length === 0) {
                return '<p class="text-gray-500 dark:text-gray-400">No data available</p>';
            }

            let processedData = data;

            if (transpose) {
                // Transpose the data for single-row tables
                // Filter out 'Party' key since party names are used as column headers
                const keys = Object.keys(data[0]).filter(key => key !== 'Party');
                const rows = keys.map(key => {
                    const row = {};
                    row[''] = key;
                    data.forEach((item, idx) => {
                        row[item['Party'] || `Value ${idx + 1}`] = item[key];
                    });
                    return row;
                });
                processedData = rows;
            }

            const headers = Object.keys(processedData[0]);
            let html = '<table>';
            html += '<thead><tr>';
            headers.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead>';
            html += '<tbody>';

            processedData.forEach(row => {
                html += '<tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">';
                const rowLabel = row[''];

                headers.forEach(header => {
                    const value = row[header] !== undefined ? row[header] : '';

                    // Check if this cell should be editable
                    let fieldKey = null;
                    if (editable) {
                        if (transpose && header !== '') {
                            // For transposed tables, check row label + column header
                            const fieldMapping = EDITABLE_FIELDS[rowLabel];
                            if (fieldMapping) {
                                if (typeof fieldMapping === 'string') {
                                    fieldKey = fieldMapping;
                                } else if (typeof fieldMapping === 'object' && fieldMapping[header]) {
                                    fieldKey = fieldMapping[header];
                                }
                            }
                        } else if (!transpose) {
                            // For non-transposed tables, check the column header directly
                            const fieldMapping = EDITABLE_FIELDS[header];
                            if (typeof fieldMapping === 'string') {
                                fieldKey = fieldMapping;
                            }
                        }
                    }

                    if (fieldKey) {
                        // Editable cell with input
                        const numericValue = inputValues[fieldKey];
                        html += `<td class="p-0">
                            <input type="number"
                                   step="0.05"
                                   value="${numericValue}"
                                   data-field="${fieldKey}"
                                   class="editable-input"
                                   onchange="handleEditableChange(this)"
                                   oninput="handleEditableChange(this)">
                        </td>`;
                    } else {
                        // Regular read-only cell
                        html += `<td>${value}</td>`;
                    }
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
        }

        // Helper function to create analysis objects from current input values
        function createAnalysis() {
            // Get values from inputValues object (percent to decimal)
            const aFixed = inputValues.a_fixed / 100;
            const aFloatDelta = inputValues.a_float_delta / 100;
            const bFixed = inputValues.b_fixed / 100;
            const bFloatDelta = inputValues.b_float_delta / 100;
            const swapFixedRate = inputValues.swap_fixed_rate / 100;
            const swapFloatingRate = inputValues.swap_floating_rate / 100;

            // Create party objects
            const partyA = new Party('Party A', aFixed, aFloatDelta, 'fixed');
            const partyB = new Party('Party B', bFixed, bFloatDelta, 'floating');

            // Determine who pays fixed
            const opportunityAnalyzer = new OpportunityAnalyzer(partyA, partyB);
            const fixedPayer = opportunityAnalyzer.findFixedRatePayer();
            const floatingPayer = fixedPayer === partyA ? partyB : partyA;

            // Create swap
            const swap = new InterestRateSwap(
                swapFixedRate,
                swapFloatingRate,
                NOTIONAL,
                fixedPayer,
                floatingPayer,
                START_DATE,
                END_DATE
            );

            // Create analyzer and get summary
            const analyzer = new InterestRateSwapAnalyzer(partyA, partyB, swap);
            const summary = analyzer.analyze();

            return { analyzer, summary };
        }

        // Update only read-only parts (called on input change to avoid focus loss)
        function updateCalculations() {
            try {
                const { analyzer, summary } = createAnalysis();

                // Update Total Arbitrage in highlight box
                document.getElementById('total_arbitrage').textContent =
                    (summary.totalArbitrage * 100).toFixed(2) + '%';

                // Update Party Positions table (read-only, safe to rebuild)
                document.getElementById('party_positions_table').innerHTML =
                    createTable(analyzer.toPartyPositionsData(summary), { transpose: true });

            } catch (error) {
                console.error('Error updating calculations:', error);
            }
        }

        // Initialize all tables including editable ones (called on page load)
        function initializeTables() {
            try {
                const { analyzer, summary } = createAnalysis();

                // Build Market Rates table (editable)
                document.getElementById('market_rates_table').innerHTML =
                    createTable(analyzer.toMarketRatesData(), { transpose: true, editable: true });

                // Build Swap Details table (editable)
                document.getElementById('swap_details_table').innerHTML =
                    createTable(analyzer.toSwapDetailsData(summary), { editable: true });

                // Update read-only parts
                updateCalculations();

            } catch (error) {
                console.error('Error initializing tables:', error);
            }
        }

        // Run initialization on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeTables();
        });
    </script>
</body>
</html>
