<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interest Rate Swap Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class'
        }
    </script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .table-container {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
        }
        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .dark th, .dark td {
            border-bottom-color: #374151;
        }
        th {
            background-color: #f9fafb;
            font-weight: 600;
            color: #374151;
        }
        .dark th {
            background-color: #1f2937;
            color: #e5e7eb;
        }
        td {
            color: #374151;
        }
        .dark td {
            color: #e5e7eb;
        }
        tr:hover {
            background-color: #f9fafb;
        }
        .dark tr:hover {
            background-color: #1f2937;
        }
        .section-header {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #3b82f6;
            transition: color 0.3s ease;
        }
        .dark .section-header {
            color: #f3f4f6;
        }
        .dark-mode-toggle {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 50;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            padding: 0.5rem;
            cursor: pointer;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .dark .dark-mode-toggle {
            background-color: #1f2937;
            border-color: #4b5563;
        }
        .dark-mode-toggle:hover {
            background-color: #f9fafb;
        }
        .dark .dark-mode-toggle:hover {
            background-color: #374151;
        }
        .icon {
            width: 1.5rem;
            height: 1.5rem;
            display: block;
        }
        /* Editable table input styling */
        .editable-input {
            background: transparent;
            border: none;
            width: 100%;
            padding: 0.75rem;
            font-size: inherit;
            color: inherit;
            text-align: right;
            transition: background-color 0.2s ease;
        }
        .editable-input:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }
        .editable-input:focus {
            outline: none;
            background-color: rgba(59, 130, 246, 0.15);
            box-shadow: inset 0 0 0 2px #3b82f6;
        }
        .dark .editable-input:hover {
            background-color: rgba(59, 130, 246, 0.2);
        }
        .dark .editable-input:focus {
            background-color: rgba(59, 130, 246, 0.25);
        }
        /* Remove spinner from number inputs */
        .editable-input::-webkit-outer-spin-button,
        .editable-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .editable-input[type=number] {
            -moz-appearance: textfield;
        }
        /* Subsection header */
        .subsection-header {
            font-size: 0.875rem;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .dark .subsection-header {
            color: #9ca3af;
        }
        /* SVG Diagram Styles */
        .swap-diagram-svg {
            width: 100%;
            max-width: 800px;
            height: auto;
            aspect-ratio: 800 / 300;
            margin: 0 auto;
            display: block;
        }
        .swap-diagram-svg text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .swap-diagram-svg .market-label {
            font-size: 11px;
            font-weight: 600;
            fill: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .dark .swap-diagram-svg .market-label {
            fill: #9ca3af;
        }
        .swap-diagram-svg .market-rate {
            font-size: 12px;
            font-weight: 500;
            fill: #374151;
        }
        .dark .swap-diagram-svg .market-rate {
            fill: #d1d5db;
        }
        .swap-diagram-svg .market-rate.dimmed {
            fill: #9ca3af;
            font-weight: 400;
        }
        .dark .swap-diagram-svg .market-rate.dimmed {
            fill: #6b7280;
        }
        .swap-diagram-svg .market-arrow {
            stroke: #9ca3af;
            stroke-width: 2;
            fill: none;
        }
        .swap-diagram-svg .party-box {
            stroke: #3b82f6;
            stroke-width: 2;
        }
        .dark .swap-diagram-svg .party-box {
            stroke: #60a5fa;
        }
        .swap-diagram-svg .party-name {
            font-size: 16px;
            font-weight: 700;
            fill: #1e40af;
        }
        .dark .swap-diagram-svg .party-name {
            fill: #93c5fd;
        }
        .swap-diagram-svg .party-role {
            font-size: 11px;
            fill: #6b7280;
            font-style: italic;
        }
        .dark .swap-diagram-svg .party-role {
            fill: #9ca3af;
        }
        .swap-diagram-svg .net-box {
            fill: #f9fafb;
            stroke: none;
        }
        .dark .swap-diagram-svg .net-box {
            fill: #1f2937;
        }
        .swap-diagram-svg .net-label {
            font-size: 11px;
            fill: #6b7280;
        }
        .dark .swap-diagram-svg .net-label {
            fill: #9ca3af;
        }
        .swap-diagram-svg .net-rate {
            font-size: 14px;
            font-weight: 600;
            fill: #1f2937;
        }
        .dark .swap-diagram-svg .net-rate {
            fill: #f3f4f6;
        }
        .swap-diagram-svg .net-comparison {
            font-size: 10px;
            fill: #6b7280;
        }
        .dark .swap-diagram-svg .net-comparison {
            fill: #9ca3af;
        }
        .swap-diagram-svg .net-benefit {
            font-size: 12px;
            font-weight: 600;
            fill: #059669;
        }
        .dark .swap-diagram-svg .net-benefit {
            fill: #34d399;
        }
        .swap-diagram-svg .swap-arrow {
            stroke-width: 2;
            fill: none;
        }
        .swap-diagram-svg .swap-arrow.fixed {
            stroke: #d97706;
        }
        .swap-diagram-svg .swap-arrow.floating {
            stroke: #059669;
        }
        .swap-diagram-svg .flow-bg.fixed {
            fill: #fef3c7;
        }
        .dark .swap-diagram-svg .flow-bg.fixed {
            fill: #78350f;
        }
        .swap-diagram-svg .flow-bg.floating {
            fill: #d1fae5;
        }
        .dark .swap-diagram-svg .flow-bg.floating {
            fill: #064e3b;
        }
        .swap-diagram-svg .flow-text.fixed {
            font-size: 11px;
            font-weight: 600;
            fill: #92400e;
        }
        .dark .swap-diagram-svg .flow-text.fixed {
            fill: #fcd34d;
        }
        .swap-diagram-svg .flow-text.floating {
            font-size: 11px;
            font-weight: 600;
            fill: #065f46;
        }
        .dark .swap-diagram-svg .flow-text.floating {
            fill: #6ee7b7;
        }
        .swap-diagram-svg .rate-value {
            font-size: 13px;
            font-weight: 700;
        }
        @media (max-width: 640px) {
            .swap-diagram-svg {
                max-width: 100%;
            }
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300">
    <!-- Dark Mode Toggle -->
    <button id="darkModeToggle" class="dark-mode-toggle" aria-label="Toggle dark mode" title="Toggle dark mode">
        <svg id="sunIcon" class="icon text-gray-700 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
        </svg>
        <svg id="moonIcon" class="icon text-gray-700 dark:text-gray-300 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
        </svg>
    </button>

    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <h1 class="text-4xl font-bold text-gray-900 dark:text-gray-100 mb-8 transition-colors">Interest Rate Swap Analysis</h1>

        <!-- Swap Flow Diagram (SVG) -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-6 transition-colors">
            <h2 class="section-header">Swap Structure</h2>
            <svg id="swap_diagram" class="swap-diagram-svg" viewBox="0 0 800 300" preserveAspectRatio="xMidYMid meet">
                <!-- Definitions -->
                <defs>
                    <!-- Arrow markers (orient="auto" handles direction, same shape for both) -->
                    <marker id="arrowOrange" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                        <path d="M0,0 L0,6 L9,3 z" fill="#d97706"/>
                    </marker>
                    <marker id="arrowGreen" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                        <path d="M0,0 L0,6 L9,3 z" fill="#059669"/>
                    </marker>
                    <!-- Gradients for party boxes -->
                    <linearGradient id="partyGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#eff6ff"/>
                        <stop offset="100%" style="stop-color:#dbeafe"/>
                    </linearGradient>
                    <linearGradient id="partyGradientDark" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#1e3a5f"/>
                        <stop offset="100%" style="stop-color:#1e40af"/>
                    </linearGradient>
                </defs>

                <!-- Party A Side (centered at x=115) -->
                <g class="party-a-group">
                    <!-- Market section -->
                    <text x="115" y="20" text-anchor="middle" class="market-label">MARKET</text>
                    <text x="115" y="38" text-anchor="middle" class="market-rate" id="diagram_a_fixed">Pays Fixed: 10.45%</text>
                    <text x="115" y="54" text-anchor="middle" class="market-rate dimmed" id="diagram_a_float">(Pays Float: S+75)</text>
                    <!-- Market arrow pointing up (drawn as path with arrowhead) -->
                    <path d="M115,92 L115,68 M110,73 L115,63 L120,73" class="market-arrow" stroke-linecap="round" stroke-linejoin="round"/>

                    <!-- Party box -->
                    <rect x="40" y="95" width="150" height="60" rx="8" class="party-box" fill="url(#partyGradient)"/>
                    <text x="115" y="122" text-anchor="middle" class="party-name">Party A</text>
                    <text x="115" y="140" text-anchor="middle" class="party-role" id="diagram_a_role">(Fixed Payer)</text>

                    <!-- Net position box -->
                    <rect x="40" y="170" width="150" height="75" rx="6" class="net-box"/>
                    <text x="115" y="188" text-anchor="middle" class="net-label">Net Cost:</text>
                    <text x="115" y="208" text-anchor="middle" class="net-rate" id="diagram_a_net">10.25%</text>
                    <text x="115" y="224" text-anchor="middle" class="net-comparison" id="diagram_a_vs">(vs 10.45% market)</text>
                    <text x="115" y="240" text-anchor="middle" class="net-benefit" id="diagram_a_benefit">Benefit: 0.20%</text>
                </g>

                <!-- Party B Side (centered at x=685) -->
                <g class="party-b-group">
                    <!-- Market section -->
                    <text x="685" y="20" text-anchor="middle" class="market-label">MARKET</text>
                    <text x="685" y="38" text-anchor="middle" class="market-rate dimmed" id="diagram_b_fixed">(Pays Fixed: 9.65%)</text>
                    <text x="685" y="54" text-anchor="middle" class="market-rate" id="diagram_b_float">Pays Float: S+25</text>
                    <!-- Market arrow pointing up (drawn as path with arrowhead) -->
                    <path d="M685,92 L685,68 M680,73 L685,63 L690,73" class="market-arrow" stroke-linecap="round" stroke-linejoin="round"/>

                    <!-- Party box -->
                    <rect x="610" y="95" width="150" height="60" rx="8" class="party-box" fill="url(#partyGradient)"/>
                    <text x="685" y="122" text-anchor="middle" class="party-name">Party B</text>
                    <text x="685" y="140" text-anchor="middle" class="party-role" id="diagram_b_role">(Floating Payer)</text>

                    <!-- Net position box -->
                    <rect x="610" y="170" width="150" height="75" rx="6" class="net-box"/>
                    <text x="685" y="188" text-anchor="middle" class="net-label">Net Cost:</text>
                    <text x="685" y="208" text-anchor="middle" class="net-rate" id="diagram_b_net">S+55</text>
                    <text x="685" y="224" text-anchor="middle" class="net-comparison" id="diagram_b_vs">(vs S+25 market)</text>
                    <text x="685" y="240" text-anchor="middle" class="net-benefit" id="diagram_b_benefit">Benefit: 0.10%</text>
                </g>

                <!-- Swap Flow Arrows -->
                <g class="swap-arrows">
                    <!-- Fixed rate flow -->
                    <line id="fixed_arrow_line" x1="195" y1="112" x2="605" y2="112" class="swap-arrow fixed" marker-end="url(#arrowOrange)"/>
                    <rect x="300" y="100" width="200" height="24" rx="4" class="flow-bg fixed"/>
                    <text x="320" y="116" class="flow-text fixed" id="diagram_fixed_payer">A Pays</text>
                    <text x="400" y="116" text-anchor="middle" class="flow-text fixed rate-value" id="diagram_fixed_rate">9.60%</text>
                    <text x="480" y="116" text-anchor="end" class="flow-text fixed" id="diagram_fixed_receiver">B Receives</text>

                    <!-- Floating rate flow -->
                    <line id="float_arrow_line" x1="605" y1="138" x2="195" y2="138" class="swap-arrow floating" marker-end="url(#arrowGreen)"/>
                    <rect x="300" y="126" width="200" height="24" rx="4" class="flow-bg floating"/>
                    <text x="320" y="142" class="flow-text floating" id="diagram_float_receiver">A Receives</text>
                    <text x="400" y="142" text-anchor="middle" class="flow-text floating rate-value" id="diagram_float_rate">S+10</text>
                    <text x="480" y="142" text-anchor="end" class="flow-text floating" id="diagram_float_payer">B Pays</text>
                </g>
            </svg>
        </div>

        <!-- Two Column Results Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Market Analysis (Left Column) -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors">
                <h2 class="section-header">Market Analysis</h2>

                <h3 class="subsection-header">Market Rates <span class="text-blue-500 dark:text-blue-400">(editable)</span></h3>
                <div class="table-container mb-6" id="market_rates_table"></div>

                <!-- Total Arbitrage Highlight Box -->
                <div class="p-4 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900/30 dark:to-indigo-900/30 rounded-lg border border-blue-200 dark:border-blue-700">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Total Arbitrage Available:</span>
                        <span id="total_arbitrage" class="text-xl font-bold text-blue-600 dark:text-blue-400">0.00%</span>
                    </div>
                    <div class="flex items-center justify-between text-sm">
                        <span class="text-gray-600 dark:text-gray-400">Optimal Fixed Payer:</span>
                        <span id="optimal_fixed_payer" class="font-medium text-green-600 dark:text-green-400">Party A</span>
                    </div>
                </div>
            </div>

            <!-- Swap Analysis (Right Column) -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors">
                <h2 class="section-header">Swap Analysis</h2>

                <!-- Fixed Payer Selection -->
                <div class="mb-4">
                    <label for="fixed_payer_select" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        Select Fixed Rate Payer:
                    </label>
                    <select id="fixed_payer_select"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            onchange="handleFixedPayerChange(this)">
                        <option value="Party A">Party A pays fixed</option>
                        <option value="Party B">Party B pays fixed</option>
                    </select>
                </div>

                <h3 class="subsection-header">Swap Terms <span class="text-blue-500 dark:text-blue-400">(editable)</span></h3>
                <div class="table-container mb-6" id="swap_details_table"></div>

                <h3 class="subsection-header">Party Positions</h3>
                <div class="table-container" id="party_positions_table"></div>
            </div>
        </div>
    </div>

    <script>
        // Update SVG gradients for dark mode
        function updateSvgDarkMode(isDark) {
            const partyBoxes = document.querySelectorAll('.party-box');
            partyBoxes.forEach(box => {
                box.setAttribute('fill', isDark ? 'url(#partyGradientDark)' : 'url(#partyGradient)');
            });
        }

        // Dark Mode Management
        function initDarkMode() {
            const htmlElement = document.documentElement;
            const darkModeToggle = document.getElementById('darkModeToggle');
            const sunIcon = document.getElementById('sunIcon');
            const moonIcon = document.getElementById('moonIcon');

            // Check for saved preference or default to system preference
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (savedTheme === 'dark' || (!savedTheme && systemPrefersDark)) {
                htmlElement.classList.add('dark');
                htmlElement.classList.remove('light');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
                updateSvgDarkMode(true);
            } else {
                htmlElement.classList.remove('dark');
                htmlElement.classList.add('light');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
                updateSvgDarkMode(false);
            }

            // Toggle function
            darkModeToggle.addEventListener('click', () => {
                const isDark = htmlElement.classList.contains('dark');

                if (isDark) {
                    htmlElement.classList.remove('dark');
                    htmlElement.classList.add('light');
                    localStorage.setItem('theme', 'light');
                    sunIcon.classList.remove('hidden');
                    moonIcon.classList.add('hidden');
                    updateSvgDarkMode(false);
                } else {
                    htmlElement.classList.add('dark');
                    htmlElement.classList.remove('light');
                    localStorage.setItem('theme', 'dark');
                    sunIcon.classList.add('hidden');
                    moonIcon.classList.remove('hidden');
                    updateSvgDarkMode(true);
                }
            });
        }

        // Initialize dark mode before page fully loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initDarkMode);
        } else {
            initDarkMode();
        }

        // Constants
        const NOTIONAL = 1000000.0;
        const START_DATE = new Date();
        const END_DATE = new Date('2030-01-01');

        // InterestRate class
        class InterestRate {
            constructor(rate, rateType) {
                if (typeof rate !== 'number') {
                    throw new Error('Rate must be a number');
                }
                if (rateType !== 'fixed' && rateType !== 'floating') {
                    throw new Error('Rate type must be fixed or floating');
                }
                this.rate = rate;
                this.rateType = rateType;
            }

            get isFloating() {
                return this.rateType === 'floating';
            }

            subtract(other) {
                if (typeof other === 'number') {
                    return new InterestRate(this.rate - other, this.rateType);
                } else if (other instanceof InterestRate) {
                    const newType = this.isFloating || other.isFloating ? 'floating' : 'fixed';
                    return new InterestRate(this.rate - other.rate, newType);
                }
                throw new Error('Unsupported operand type for subtract');
            }

            toString() {
                if (this.rateType === 'fixed') {
                    return (this.rate * 100).toFixed(2) + '%';
                } else {
                    const bps = Math.abs(Math.round(this.rate * 10000));
                    const sign = this.rate >= 0 ? '+' : '-';
                    return `S${sign}${bps}`;
                }
            }
        }

        // Party class
        class Party {
            constructor(name, fixedRate, floatingRateDelta, preference) {
                this.name = name;
                this._fixedRate = new InterestRate(fixedRate, 'fixed');
                this._floatingRateDelta = new InterestRate(floatingRateDelta, 'floating');
                if (preference !== 'fixed' && preference !== 'floating') {
                    throw new Error('Preference must be fixed or floating');
                }
                this.preference = preference;
            }

            get fixedRate() {
                return this._fixedRate;
            }

            get floatingRateDelta() {
                return this._floatingRateDelta;
            }

            getRate(type) {
                if (type === 'fixed') {
                    return this.fixedRate;
                } else {
                    return this.floatingRateDelta;
                }
            }
        }

        // InterestRateSwap class
        class InterestRateSwap {
            constructor(fixedRate, floatingRateDelta, notional, fixedRatePayer, floatingRatePayer, startDate, endDate) {
                if (notional <= 0) {
                    throw new Error('Notional must be positive');
                }
                if (startDate >= endDate) {
                    throw new Error('Start date must be before end date');
                }

                this._fixedRate = new InterestRate(fixedRate, 'fixed');
                this._floatingRateDelta = new InterestRate(floatingRateDelta, 'floating');
                this.notional = notional;
                this.fixedRatePayer = fixedRatePayer;
                this.floatingRatePayer = floatingRatePayer;
                this.startDate = startDate;
                this.endDate = endDate;
            }

            get fixedRate() {
                return this._fixedRate;
            }

            get floatingRateDelta() {
                return this._floatingRateDelta;
            }

            getPayingPositionForParty(party) {
                return party === this.fixedRatePayer ? 'fixed' : 'floating';
            }

            getReceivingPositionForParty(party) {
                if (party === this.fixedRatePayer) {
                    return 'floating';
                } else if (party === this.floatingRatePayer) {
                    return 'fixed';
                }
                return null;
            }

            getRate(type) {
                if (type === 'fixed') {
                    return this.fixedRate;
                } else {
                    return this.floatingRateDelta;
                }
            }
        }

        // OpportunityAnalyzer class
        class OpportunityAnalyzer {
            constructor(partyA, partyB) {
                this.partyA = partyA;
                this.partyB = partyB;
                this._comparatives = null;
                this._comparativeAdvantages = null;
                this._comparativeDisadvantages = null;
            }

            get comparatives() {
                if (!this._comparatives) {
                    this._comparatives = {};
                    this._comparatives[this.partyA.name] = this.comparativesForParty(this.partyA);
                    this._comparatives[this.partyB.name] = this.comparativesForParty(this.partyB);
                }
                return this._comparatives;
            }

            get comparativeAdvantages() {
                if (!this._comparativeAdvantages) {
                    this._comparativeAdvantages = {};
                    this._comparativeAdvantages[this.partyA.name] = this.determineComparativeAdvantageForParty(this.partyA);
                    this._comparativeAdvantages[this.partyB.name] = this.determineComparativeAdvantageForParty(this.partyB);
                }
                return this._comparativeAdvantages;
            }

            get comparativeDisadvantages() {
                if (!this._comparativeDisadvantages) {
                    this._comparativeDisadvantages = {};
                    this._comparativeDisadvantages[this.partyA.name] = this.determineComparativeDisadvantageForParty(this.partyA);
                    this._comparativeDisadvantages[this.partyB.name] = this.determineComparativeDisadvantageForParty(this.partyB);
                }
                return this._comparativeDisadvantages;
            }

            comparativesForParty(party) {
                const counterparty = party === this.partyA ? this.partyB : this.partyA;
                const fixedDiff = party.fixedRate.subtract(counterparty.fixedRate);
                const floatDiff = party.floatingRateDelta.subtract(counterparty.floatingRateDelta);
                return { fixed: fixedDiff.rate, floating: floatDiff.rate };
            }

            determineComparativeAdvantageForParty(party) {
                const comp = this.comparatives[party.name];
                if (comp.fixed < comp.floating) {
                    return { type: 'fixed', rate: comp.fixed };
                } else if (comp.floating < comp.fixed) {
                    return { type: 'floating', rate: comp.floating };
                } else {
                    return { type: 'none', rate: 0 };
                }
            }

            determineComparativeDisadvantageForParty(party) {
                const comp = this.comparatives[party.name];
                if (comp.fixed > comp.floating) {
                    return { type: 'fixed', rate: comp.fixed };
                } else if (comp.floating > comp.fixed) {
                    return { type: 'floating', rate: comp.floating };
                } else {
                    return { type: 'none', rate: 0 };
                }
            }

            calculateTotalArbitrageAvailable() {
                return -(this.comparativeAdvantages[this.partyA.name].rate +
                         this.comparativeAdvantages[this.partyB.name].rate);
            }

            findFixedRatePayer() {
                if (this.comparativeAdvantages[this.partyA.name].type === 'fixed') {
                    return this.partyB;
                } else if (this.comparativeAdvantages[this.partyB.name].type === 'fixed') {
                    return this.partyA;
                } else {
                    return this.partyA.fixedRate.rate > this.partyB.fixedRate.rate ? this.partyA : this.partyB;
                }
            }
        }

        // InterestRateSwapAnalyzer class
        class InterestRateSwapAnalyzer {
            constructor(partyA, partyB, interestRateSwap) {
                if (!partyA || !partyB || !interestRateSwap) {
                    throw new Error('All parameters must be provided');
                }
                this.partyA = partyA;
                this.partyB = partyB;
                this.interestRateSwap = interestRateSwap;
                this.opportunityAnalyzer = new OpportunityAnalyzer(partyA, partyB);
            }

            analyze() {
                const partyAAnalysis = this.analyzeParty(this.partyA);
                const partyBAnalysis = this.analyzeParty(this.partyB);

                return {
                    totalArbitrage: this.opportunityAnalyzer.calculateTotalArbitrageAvailable(),
                    fixedRate: this.interestRateSwap.fixedRate.rate,
                    floatingRate: this.interestRateSwap.floatingRateDelta.rate,
                    partyAAnalysis: partyAAnalysis,
                    partyBAnalysis: partyBAnalysis
                };
            }

            // Get market borrowing position based on swap position
            // Fixed payer in swap â†’ borrows floating in market (and vice versa)
            getMarketPositionForParty(party) {
                const swapPayingPosition = this.interestRateSwap.getPayingPositionForParty(party);
                return swapPayingPosition === 'fixed' ? 'floating' : 'fixed';
            }

            analyzeParty(party) {
                const payingPosition = this.interestRateSwap.getPayingPositionForParty(party);
                const receivingPosition = this.interestRateSwap.getReceivingPositionForParty(party);
                const marketPosition = this.getMarketPositionForParty(party);
                const benefit = this.getMarketPayingVsSwapReceivingBenefit(party);

                return {
                    party: party,
                    comparativeAdvantage: this.opportunityAnalyzer.comparativeAdvantages[party.name],
                    marketPosition: marketPosition,  // What they borrow in market
                    marketPayingVsSwapReceivingBenefit: benefit,
                    payingPosition: payingPosition,
                    receivingPosition: receivingPosition,
                    marketImprovement: this.calculateMarketImprovement(party),
                    totalCost: this.calculateTotalCost(party)
                };
            }

            calculateMarketImprovement(party) {
                // Compare net cost to what they would pay in market for their desired rate type
                // Desired rate type = opposite of market position (what they're converting TO via swap)
                const marketPosition = this.getMarketPositionForParty(party);
                const desiredPosition = marketPosition === 'fixed' ? 'floating' : 'fixed';
                const directMarketRate = party.getRate(desiredPosition).rate;
                const netCost = this.calculateTotalCost(party);
                return directMarketRate - netCost;
            }

            calculateTotalCost(party) {
                // Net cost = swap_paying_rate + market_borrowing_rate - swap_receiving_rate
                const swapPayingRate = this.interestRateSwap.getRate(
                    this.interestRateSwap.getPayingPositionForParty(party)
                ).rate;
                const marketBorrowingRate = party.getRate(this.getMarketPositionForParty(party)).rate;
                const swapReceivingRate = this.interestRateSwap.getRate(
                    this.interestRateSwap.getReceivingPositionForParty(party)
                ).rate;
                return swapPayingRate + marketBorrowingRate - swapReceivingRate;
            }

            getMarketPayingVsSwapReceivingBenefit(party) {
                // Benefit from receiving swap rate vs paying market rate
                const marketRate = party.getRate(this.getMarketPositionForParty(party)).rate;
                const swapReceivingRate = this.interestRateSwap.getRate(
                    this.interestRateSwap.getReceivingPositionForParty(party)
                ).rate;
                return swapReceivingRate - marketRate;
            }

            toMarketRatesData() {
                return [
                    {
                        'Party': 'Party A',
                        'Fixed Rate (Market)': this.partyA.fixedRate.toString(),
                        'Floating Rate (Market)': this.partyA.floatingRateDelta.toString()
                    },
                    {
                        'Party': 'Party B',
                        'Fixed Rate (Market)': this.partyB.fixedRate.toString(),
                        'Floating Rate (Market)': this.partyB.floatingRateDelta.toString()
                    }
                ];
            }

            toSwapDetailsData(summary) {
                return [{
                    'Swap Fixed Rate': this.interestRateSwap.fixedRate.toString(),
                    'Swap Floating Rate': this.interestRateSwap.floatingRateDelta.toString()
                }];
            }

            toPartyPositionsData(summary) {
                const data = [];
                for (const partyAnalysis of [summary.partyAAnalysis, summary.partyBAnalysis]) {
                    const payingRate = this.interestRateSwap.getRate(partyAnalysis.payingPosition);
                    const receivingRate = this.interestRateSwap.getRate(partyAnalysis.receivingPosition);
                    const marketPositionType = this.opportunityAnalyzer.comparativeAdvantages[partyAnalysis.party.name].type;
                    const marketRate = partyAnalysis.party.getRate(marketPositionType);

                    const oppositeMarketPosition = marketPositionType === 'fixed' ? 'floating' : 'fixed';
                    const oppositeMarketRate = partyAnalysis.party.getRate(oppositeMarketPosition);

                    const netPosition = payingRate.subtract(this.getMarketPayingVsSwapReceivingBenefit(partyAnalysis.party));
                    const netMarketBenefit = oppositeMarketRate.rate - netPosition.rate;

                    data.push({
                        'Party': partyAnalysis.party.name,
                        'Swap Paying Rate': payingRate.toString(),
                        'Swap Receiving Rate': receivingRate.toString(),
                        'Market Position': marketRate.toString(),
                        'Benefit': (this.getMarketPayingVsSwapReceivingBenefit(partyAnalysis.party) * 100).toFixed(2) + '%',
                        'Net Position': netPosition.toString(),
                        'Net Market Benefit': (netMarketBenefit * 100).toFixed(2) + '%'
                    });
                }
                return data;
            }
        }

        // Field mappings for editable cells
        const EDITABLE_FIELDS = {
            'Fixed Rate (Market)': {
                'Party A': 'a_fixed',
                'Party B': 'b_fixed'
            },
            'Floating Rate (Market)': {
                'Party A': 'a_float_delta',
                'Party B': 'b_float_delta'
            },
            'Swap Fixed Rate': 'swap_fixed_rate',
            'Swap Floating Rate': 'swap_floating_rate'
        };

        // Current input values (initialized with defaults, updated by editable inputs)
        let inputValues = {
            a_fixed: 10.45,
            a_float_delta: 0.75,
            b_fixed: 9.65,
            b_float_delta: 0.25,
            swap_fixed_rate: 9.6,
            swap_floating_rate: 0.10,
            fixed_payer: 'Party A'  // Manual selection for teaching
        };

        // Handle editable input change - only updates read-only parts to avoid focus loss
        function handleEditableChange(inputElement) {
            const field = inputElement.dataset.field;
            const value = parseFloat(inputElement.value);

            if (!isNaN(value)) {
                inputValues[field] = value;
                updateCalculations();  // Only update read-only parts, not editable tables
            }
        }

        // Handle fixed payer selection change
        function handleFixedPayerChange(selectElement) {
            inputValues.fixed_payer = selectElement.value;
            updateCalculations();
        }

        // Helper function to create HTML table with optional editable cells
        function createTable(data, options = {}) {
            const { transpose = false, editable = false } = options;

            if (!data || data.length === 0) {
                return '<p class="text-gray-500 dark:text-gray-400">No data available</p>';
            }

            let processedData = data;

            if (transpose) {
                // Transpose the data for single-row tables
                // Filter out 'Party' key since party names are used as column headers
                const keys = Object.keys(data[0]).filter(key => key !== 'Party');
                const rows = keys.map(key => {
                    const row = {};
                    row[''] = key;
                    data.forEach((item, idx) => {
                        row[item['Party'] || `Value ${idx + 1}`] = item[key];
                    });
                    return row;
                });
                processedData = rows;
            }

            const headers = Object.keys(processedData[0]);
            let html = '<table>';
            html += '<thead><tr>';
            headers.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead>';
            html += '<tbody>';

            processedData.forEach(row => {
                html += '<tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">';
                const rowLabel = row[''];

                headers.forEach(header => {
                    const value = row[header] !== undefined ? row[header] : '';

                    // Check if this cell should be editable
                    let fieldKey = null;
                    if (editable) {
                        if (transpose && header !== '') {
                            // For transposed tables, check row label + column header
                            const fieldMapping = EDITABLE_FIELDS[rowLabel];
                            if (fieldMapping) {
                                if (typeof fieldMapping === 'string') {
                                    fieldKey = fieldMapping;
                                } else if (typeof fieldMapping === 'object' && fieldMapping[header]) {
                                    fieldKey = fieldMapping[header];
                                }
                            }
                        } else if (!transpose) {
                            // For non-transposed tables, check the column header directly
                            const fieldMapping = EDITABLE_FIELDS[header];
                            if (typeof fieldMapping === 'string') {
                                fieldKey = fieldMapping;
                            }
                        }
                    }

                    if (fieldKey) {
                        // Editable cell with input
                        const numericValue = inputValues[fieldKey];
                        html += `<td class="p-0">
                            <input type="number"
                                   step="0.05"
                                   value="${numericValue}"
                                   data-field="${fieldKey}"
                                   class="editable-input"
                                   onchange="handleEditableChange(this)"
                                   oninput="handleEditableChange(this)">
                        </td>`;
                    } else {
                        // Regular read-only cell
                        html += `<td>${value}</td>`;
                    }
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
        }

        // Helper function to create analysis objects from current input values
        function createAnalysis() {
            // Get values from inputValues object (percent to decimal)
            const aFixed = inputValues.a_fixed / 100;
            const aFloatDelta = inputValues.a_float_delta / 100;
            const bFixed = inputValues.b_fixed / 100;
            const bFloatDelta = inputValues.b_float_delta / 100;
            const swapFixedRate = inputValues.swap_fixed_rate / 100;
            const swapFloatingRate = inputValues.swap_floating_rate / 100;

            // Create party objects
            const partyA = new Party('Party A', aFixed, aFloatDelta, 'fixed');
            const partyB = new Party('Party B', bFixed, bFloatDelta, 'floating');

            // Use manual selection for fixed payer (for teaching)
            const fixedPayer = inputValues.fixed_payer === 'Party A' ? partyA : partyB;
            const floatingPayer = fixedPayer === partyA ? partyB : partyA;

            // Create swap
            const swap = new InterestRateSwap(
                swapFixedRate,
                swapFloatingRate,
                NOTIONAL,
                fixedPayer,
                floatingPayer,
                START_DATE,
                END_DATE
            );

            // Create analyzer and get summary
            const analyzer = new InterestRateSwapAnalyzer(partyA, partyB, swap);
            const summary = analyzer.analyze();

            // Get optimal fixed payer based on comparative advantage
            const opportunityAnalyzer = new OpportunityAnalyzer(partyA, partyB);
            const optimalFixedPayer = opportunityAnalyzer.findFixedRatePayer();

            return { analyzer, summary, optimalFixedPayer };
        }

        // Update the swap diagram with current values
        function updateDiagram(analyzer, summary) {
            const swap = analyzer.interestRateSwap;

            // Get party analysis data (includes market position derived from swap)
            const partyAAnalysis = summary.partyAAnalysis;
            const partyBAnalysis = summary.partyBAnalysis;

            // Get market positions (derived from swap positions)
            const partyAMarketPos = partyAAnalysis.marketPosition;
            const partyBMarketPos = partyBAnalysis.marketPosition;

            // Party A market rates (both shown, unused one dimmed with parentheses)
            const partyAFixedEl = document.getElementById('diagram_a_fixed');
            const partyAFloatEl = document.getElementById('diagram_a_float');
            const aFixedRate = analyzer.partyA.fixedRate.toString();
            const aFloatRate = analyzer.partyA.floatingRateDelta.toString();

            if (partyAMarketPos === 'fixed') {
                // A borrows at fixed rate in market
                partyAFixedEl.textContent = `Pays Fixed: ${aFixedRate}`;
                partyAFloatEl.textContent = `(Pays Float: ${aFloatRate})`;
                partyAFixedEl.classList.remove('dimmed');
                partyAFloatEl.classList.add('dimmed');
            } else {
                // A borrows at floating rate in market
                partyAFixedEl.textContent = `(Pays Fixed: ${aFixedRate})`;
                partyAFloatEl.textContent = `Pays Float: ${aFloatRate}`;
                partyAFixedEl.classList.add('dimmed');
                partyAFloatEl.classList.remove('dimmed');
            }

            // Party B market rates (both shown, unused one dimmed with parentheses)
            const partyBFixedEl = document.getElementById('diagram_b_fixed');
            const partyBFloatEl = document.getElementById('diagram_b_float');
            const bFixedRate = analyzer.partyB.fixedRate.toString();
            const bFloatRate = analyzer.partyB.floatingRateDelta.toString();

            if (partyBMarketPos === 'fixed') {
                // B borrows at fixed rate in market
                partyBFixedEl.textContent = `Pays Fixed: ${bFixedRate}`;
                partyBFloatEl.textContent = `(Pays Float: ${bFloatRate})`;
                partyBFixedEl.classList.remove('dimmed');
                partyBFloatEl.classList.add('dimmed');
            } else {
                // B borrows at floating rate in market
                partyBFixedEl.textContent = `(Pays Fixed: ${bFixedRate})`;
                partyBFloatEl.textContent = `Pays Float: ${bFloatRate}`;
                partyBFixedEl.classList.add('dimmed');
                partyBFloatEl.classList.remove('dimmed');
            }

            // Party roles
            const isPartyAFixedPayer = swap.fixedRatePayer.name === 'Party A';
            document.getElementById('diagram_a_role').textContent =
                isPartyAFixedPayer ? '(Fixed Payer)' : '(Floating Payer)';
            document.getElementById('diagram_b_role').textContent =
                isPartyAFixedPayer ? '(Floating Payer)' : '(Fixed Payer)';

            // Swap flow rates and payer/receiver labels
            document.getElementById('diagram_fixed_rate').textContent = swap.fixedRate.toString();
            document.getElementById('diagram_float_rate').textContent = swap.floatingRateDelta.toString();

            // Update payer/receiver labels based on who pays fixed
            // Left position (x=320) = Party A's action, Right position (x=480) = Party B's action
            document.getElementById('diagram_fixed_payer').textContent =
                isPartyAFixedPayer ? 'A Pays' : 'A Receives';
            document.getElementById('diagram_fixed_receiver').textContent =
                isPartyAFixedPayer ? 'B Receives' : 'B Pays';
            document.getElementById('diagram_float_receiver').textContent =
                isPartyAFixedPayer ? 'A Receives' : 'A Pays';
            document.getElementById('diagram_float_payer').textContent =
                isPartyAFixedPayer ? 'B Pays' : 'B Receives';

            // Update arrow directions based on who pays fixed
            // Note: orient="auto" handles arrow direction automatically
            const fixedArrow = document.getElementById('fixed_arrow_line');
            const floatArrow = document.getElementById('float_arrow_line');
            if (isPartyAFixedPayer) {
                // A pays fixed to B: arrow goes left to right
                fixedArrow.setAttribute('x1', '195');
                fixedArrow.setAttribute('x2', '605');
                // B pays float to A: arrow goes right to left
                floatArrow.setAttribute('x1', '605');
                floatArrow.setAttribute('x2', '195');
            } else {
                // B pays fixed to A: arrow goes right to left
                fixedArrow.setAttribute('x1', '605');
                fixedArrow.setAttribute('x2', '195');
                // A pays float to B: arrow goes left to right
                floatArrow.setAttribute('x1', '195');
                floatArrow.setAttribute('x2', '605');
            }

            // Net positions and benefits
            const partyANetCost = partyAAnalysis.totalCost;
            const partyBNetCost = partyBAnalysis.totalCost;

            // Format net position based on what type they end up with after swap
            // Net rate type = opposite of market position (what they convert TO)
            const partyANetRateType = partyAMarketPos === 'fixed' ? 'floating' : 'fixed';
            const partyBNetRateType = partyBMarketPos === 'fixed' ? 'floating' : 'fixed';
            const partyANetRate = new InterestRate(partyANetCost, partyANetRateType);
            const partyBNetRate = new InterestRate(partyBNetCost, partyBNetRateType);

            document.getElementById('diagram_a_net').textContent = partyANetRate.toString();
            document.getElementById('diagram_b_net').textContent = partyBNetRate.toString();

            // What they would have paid in market for their desired rate type (for comparison)
            const partyAMarketAlternative = analyzer.partyA.getRate(partyANetRateType);
            const partyBMarketAlternative = analyzer.partyB.getRate(partyBNetRateType);

            document.getElementById('diagram_a_vs').textContent =
                `(vs ${partyAMarketAlternative.toString()} market)`;
            document.getElementById('diagram_b_vs').textContent =
                `(vs ${partyBMarketAlternative.toString()} market)`;

            // Benefits
            const partyABenefit = partyAAnalysis.marketImprovement * 100;
            const partyBBenefit = partyBAnalysis.marketImprovement * 100;

            document.getElementById('diagram_a_benefit').textContent =
                `Benefit: ${partyABenefit.toFixed(2)}%`;
            document.getElementById('diagram_b_benefit').textContent =
                `Benefit: ${partyBBenefit.toFixed(2)}%`;
        }

        // Update only read-only parts (called on input change to avoid focus loss)
        function updateCalculations() {
            try {
                const { analyzer, summary, optimalFixedPayer } = createAnalysis();

                // Update Optimal Fixed Payer indicator
                const optimalEl = document.getElementById('optimal_fixed_payer');
                optimalEl.textContent = optimalFixedPayer.name;
                // Highlight if current selection matches optimal
                const isOptimal = inputValues.fixed_payer === optimalFixedPayer.name;
                optimalEl.className = isOptimal
                    ? 'font-medium text-green-600 dark:text-green-400'
                    : 'font-medium text-yellow-600 dark:text-yellow-400';

                // Update Total Arbitrage in highlight box
                document.getElementById('total_arbitrage').textContent =
                    (summary.totalArbitrage * 100).toFixed(2) + '%';

                // Update Party Positions table (read-only, safe to rebuild)
                document.getElementById('party_positions_table').innerHTML =
                    createTable(analyzer.toPartyPositionsData(summary), { transpose: true });

                // Update the diagram
                updateDiagram(analyzer, summary);

            } catch (error) {
                console.error('Error updating calculations:', error);
            }
        }

        // Initialize all tables including editable ones (called on page load)
        function initializeTables() {
            try {
                const { analyzer, summary } = createAnalysis();

                // Build Market Rates table (editable)
                document.getElementById('market_rates_table').innerHTML =
                    createTable(analyzer.toMarketRatesData(), { transpose: true, editable: true });

                // Build Swap Details table (editable)
                document.getElementById('swap_details_table').innerHTML =
                    createTable(analyzer.toSwapDetailsData(summary), { editable: true });

                // Update read-only parts
                updateCalculations();

            } catch (error) {
                console.error('Error initializing tables:', error);
            }
        }

        // Run initialization on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeTables();
        });
    </script>
</body>
</html>
